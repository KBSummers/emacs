// raw protocol sample
//
// useage: raw [device name]
//
// - send data in main thread
// - receive data in receive thread
// 
// == Single Port Use ==
// Connect data and clock outputs to data and clock inputs with
// loopback plug or external cabling. Alternatively, set
// settings.internal_loopback = True.
//
// == Two Port Use ==
// Connect ports with crossover cable that:
// - connects data output of each port to data input of other port
// - connects clock output of one port to clock inputs of both ports
// Run sample on both ports.

#include <stdio.h>
#include <memory.h>
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/types.h>
#include <termios.h>
#include <errno.h>
#include <pthread.h>
#include "synclink.h"

// size of data sent in this sample
#define DATA_SIZE 100

// 1 = continuous send data (no idle between writes)
// 0 = bursts of data (zeros) separated by idle (ones)
#define CONTINUOUS_SEND 1

int run = 1;

void sigint_handler(int sigid)
{
	printf("Ctrl-C pressed\n");
	run = 0;
}

void configure_port(int fd) {
	int ldisc;
	struct termios termios;
	MGSL_PARAMS params;

	// Set line discipline, a software layer between tty devices
	// and user applications that performs intermediate processing.
	// N_TTY = byte oriented line discipline
	ldisc = N_TTY;
	ioctl(fd, TIOCSETD, &ldisc);

	// set N_TTY details with termios functions
	tcgetattr(fd, &termios);
	termios.c_iflag = 0;
	termios.c_oflag = 0;
	termios.c_cflag = CREAD | CS8 | HUPCL | CLOCAL;
	termios.c_lflag = 0;
	termios.c_cc[VTIME] = 0;
	termios.c_cc[VMIN] = DATA_SIZE;
	tcsetattr(fd, TCSANOW, &termios);

	// get, modify and set device parameters
	ioctl(fd, MGSL_IOCGPARAMS, &params);
	params.mode = MGSL_MODE_RAW;
	params.encoding = HDLC_ENCODING_NRZ;
	params.crc_type = HDLC_CRC_NONE;
	params.loopback = 0;
	params.flags = HDLC_FLAG_RXC_RXCPIN + HDLC_FLAG_TXC_TXCPIN;
	params.clock_speed = 2400;
	ioctl(fd, MGSL_IOCSPARAMS, &params);

	// set transmit idle pattern (sent between frames)
	ioctl(fd, MGSL_IOCSTXIDLE, HDLC_TXIDLE_ONES);

	// set receive data transfer size: range=1-256, default=256
	// < 128  : programmed I/O (PIO), low data rate
	// >= 128 : direct memory access (DMA), MUST be multiple of 4
	// Lower values reduce receive latency (time from receiving data
	// until it becomes available to system) but increase overhead.
	ioctl(fd, MGSL_IOCRXENABLE, (8 << 16));

	// set transmit data transfer mode
	if (CONTINUOUS_SEND) {
		ioctl(fd, MGSL_IOCTXENABLE, MGSL_ENABLE_PIO);
	} else {
		ioctl(fd, MGSL_IOCTXENABLE, MGSL_ENABLE_DMA);
	}

	// use blocking reads and writes
	fcntl(fd, F_SETFL, fcntl(fd,F_GETFL) & ~O_NONBLOCK);
}

// display buffer in hex format, 16 bytes per line
void display_buf(unsigned char *buf, int size)
{
	int i;
	for (i = 0 ; i < size ; i++) {
		if (!(i % 16))
			printf("%04X: ", i);
		if (i % 16 == 15)
			printf("%02X\n", *buf++);
		else
			printf("%02X ", *buf++);
	}
	if (i % 16)
			printf("\n");
}

// Raw mode saves a bit every clock cycle without distinguishing
// between data/idle/noise. There is no framing or byte alignment.
// Sample data = all 0. Idle pattern = all 1.
// Data is shifted 0-7 bits with bytes possibly spanning 2
// read buffer bytes. Serial bit order is LSB first.
void *receive_func(void *ptr)
{
	int fd = *((int *)ptr);
	int rc;
	unsigned char buf[DATA_SIZE];
	int i = 1;
	while (run) {
		// block until DATA_SIZE bytes received (termios VMIN)
		rc = read(fd, buf, sizeof(buf));
		if (rc < 1) {
			break;
		}
		printf("<<< %09d received %d bytes\n", i, rc);
		display_buf(buf, rc);
		i++;
	}
	return NULL;
}

int main(int argc, char* argv[])
{
	int fd;
	int rc;
	int i;
	unsigned char buf[DATA_SIZE*2];
	char *devname;
	pthread_t receive_thread;

	if (argc > 1)
		devname = argv[1];
	else
		devname = "/dev/ttySLG0";

	printf("raw sample running on %s\n", devname);

	// open with O_NONBLOCK to ignore DCD
	fd = open(devname, O_RDWR | O_NONBLOCK, 0);
	if (fd < 0) {
		printf("open error=%d %s\n", errno, strerror(errno));
		return errno;
	}

	if (strstr(devname, "USB")) {
		int arg;
		ioctl(fd, MGSL_IOCGIF, &arg);
		// uncomment to select interface (RS232,V35,RS422)
		arg = (arg & ~MGSL_INTERFACE_MASK) | MGSL_INTERFACE_RS422;
		ioctl(fd, MGSL_IOCSIF, arg);
		if (!(arg & MGSL_INTERFACE_MASK)) {
			printf("USB serial interface must be selected.\n");
			return -1;
		}
	}

	configure_port(fd);

	printf("Press Ctrl-C to stop program.\n");
	signal(SIGINT, sigint_handler);
	siginterrupt(SIGINT, 1);

	ioctl(fd, MGSL_IOCRXENABLE, 1);
	pthread_create(&receive_thread, NULL, receive_func, &fd);

	// Prepare all zeros data to contrast with all ones idle pattern.
	// Raw mode=no byte alignment, receive data may be bit shifted.
	memset(buf, 0, DATA_SIZE);

	i = 1;
	while (run) {
		printf(">>> %09d send %d bytes\n", i, DATA_SIZE);
		rc = write(fd, buf, DATA_SIZE);
		if (rc < 0) {
			break;
		}
		if (CONTINUOUS_SEND) {
			// prevent idle by keeping send count > 0
			// limit latency by keeping send count < 2*DATA_SIZE
			// latency = time from write to serial data output
			printf(">>> wait for send count <= %d\n", DATA_SIZE);
			for (;;) {
				int count;
				rc = ioctl(fd, TIOCOUTQ, &count);
				if (rc < 0 || count <= DATA_SIZE) {
					break;
				}
				usleep(5000);
			}
		} else {
			// block until all sent to insert idle between data
			tcdrain(fd);
			usleep(25000);
		}
		i++;
	}

	close(fd);
	return 0;
}