import valispace
import keyring
import requests
from anytree import NodeMixin, RenderTree
from os.path import exists

#mastenspace = valispace.API(url='https://valispace.masten.aero',
#username='ksummers', password=keyring.get_password("valispace", "ksummers"))
mm1_id = 12405
xl1_id = 12406
payloads_id = 12407
#print(mm1)
#comp_list = mastenspace.get_component_list(project_id=74)
#STRUCTURES ARE ALREADY OBTAINED
class MM1Node:
    def __init__(self, node, children):
        self.logfile = open("data.out", "w")
        mastenspace = valispace.API(url='https://valispace.masten.aero',
            username='ksummers', password=keyring.get_password("valispace", "ksummers"))
        self.node = mastenspace.get_component(id=12405) #12405 = mm1 id
        self.children = {}
        for child in self.node["children"]:
            self.children[child[""]]
        mm1 = mastenspace.get_all_data('component')
        count = 0
        for key in mm1:
            count +=1
            print(count)
            print(mm1[key]["name"])

class FswNode(NodeMixin):
    def __init__(self, name, parent=None, children=None):
        self.name = name
        self.parent = parent
        if children:
            self.children = children
    def get_sibling_nodes(self):
        siblings = {}
        if parent:
            for node in self.parent["children"]:
                if(node["name"] != self.name):
                    siblings[node["name"]] = node



def initialize():
    mastenspace = valispace.API(url='https://valispace.masten.aero',
            username='ksummers', password=keyring.get_password("valispace", "ksummers"))
    mm1 = call_component(mm1_id, mastenspace) #12405 = mm1 id
    xl1 = call_component(xl1_id, mastenspace)
    payloads = call_component(payloads_id, mastenspace)
    #launch_vehicle =
    #ground_systems =
    #ait =
    subsystems = {}
    print(xl1)
    for child in xl1["children"]:
        x = call_component(child, mastenspace)
        #temp = x["name"]
        #subsystems[temp] = x
        #subsystems[x["name"]] = x
        # now we need to add the properties (valis) from each and add the ones that are importantsss
    query_yes_no("this is a quesiton")

def print_tree(parent):
    for pre, _, node in RenderTree(parent):
        treestr = u"%s%s" % (pre, node.name)
        print(treestr.ljust(8), node.length, node.width)

def call_component(comp_id, mastenspace):
    try:
        req=mastenspace.get_component(id=comp_id)
        if req is None:
            req.raise_for_status()
    except requests.HTTPError as exception:
        print("Error accessing component with id: " + str(comp_id))
        return
    return req

def call_vali(vali_id, mastenspace):
    try:
        req=mastenspace.get_vali(id=vali_id)
        if req is None:
            req.raise_for_status()
    except requests.HTTPError as exception:
        print("Error accessing vali with id: " + str(vali_id))
        return
    return req

# Function will walk through a components properties (1 by 1) asking
# which are important. When we determine that they are important they
# will be added to a new tree node that will be returned by this function
def walk_component(comp_id, mastenspace):
    tmp = call_component(comp_id,mastenspace)
    if tmp["children"]:
        for child in temp["children"]:
            ch_tmp = call_component(child, mastenspace)
            # std out ask if important, do same with valis probably aboe this
#def walk_valis()

#def print_to_csv(filename, )

def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is one of "yes" or "no".
    """
    valid = {"yes":"yes",   "y":"yes",  "ye":"yes",
             "no":"no",     "n":"no"}
    if default == None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while 1:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return default
        elif choice in valid.keys():
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "\
                             "(or 'y' or 'n').\n")
initialize()
